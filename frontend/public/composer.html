<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Composer - Sankalpa</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
      margin: 0;
      padding: 0;
      color: #333;
      background-color: #f9f9f9;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }
    header {
      background-color: #4f46e5;
      color: white;
      padding: 1rem 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    main {
      padding: 2rem 0;
    }
    footer {
      background-color: #f1f1f1;
      padding: 1rem 0;
      text-align: center;
      border-top: 1px solid #ddd;
      margin-top: 2rem;
    }
    h1 {
      font-size: 2rem;
      margin-bottom: 1.5rem;
    }
    .flex {
      display: flex;
      gap: 1rem;
    }
    @media (max-width: 768px) {
      .flex {
        flex-direction: column;
      }
    }
    .card {
      background: white;
      border-radius: 0.5rem;
      padding: 1.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      border: 1px solid #eee;
    }
    .action-bar {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    .button {
      background-color: #4f46e5;
      color: white;
      border: none;
      border-radius: 0.25rem;
      padding: 0.5rem 1rem;
      font-size: 1rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .button:hover {
      background-color: #4338ca;
    }
    .button-blue {
      background-color: #2563eb;
    }
    .button-blue:hover {
      background-color: #1d4ed8;
    }
    .button-green {
      background-color: #059669;
    }
    .button-green:hover {
      background-color: #047857;
    }
    .button-purple {
      background-color: #7c3aed;
    }
    .button-purple:hover {
      background-color: #6d28d9;
    }
    .button-gray {
      background-color: #4b5563;
      margin-left: auto;
    }
    .button-gray:hover {
      background-color: #374151;
    }
    .canvas {
      border: 2px dashed #ccc;
      border-radius: 0.5rem;
      height: 300px;
      position: relative;
      margin-bottom: 1rem;
      background-color: #f5f5f5;
      overflow: hidden;
    }
    .node {
      position: absolute;
      background-color: white;
      border: 1px solid #ddd;
      border-radius: 0.25rem;
      padding: 0.5rem;
      min-width: 100px;
      text-align: center;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      user-select: none;
      cursor: move;
    }
    .output-container {
      background-color: #f5f5f5;
      border-radius: 0.25rem;
      padding: 1rem;
      max-height: 200px;
      overflow-y: auto;
    }
    pre {
      margin: 0;
      font-family: monospace;
      white-space: pre-wrap;
    }
    .chat-container {
      display: flex;
      flex-direction: column;
      height: 400px;
      border-radius: 0.5rem;
      overflow: hidden;
      border: 1px solid #eee;
    }
    .chat-header {
      background-color: #f5f5f5;
      padding: 0.75rem;
      border-bottom: 1px solid #eee;
      font-weight: 500;
    }
    .chat-messages {
      flex-grow: 1;
      padding: 1rem;
      overflow-y: auto;
    }
    .message {
      margin-bottom: 0.75rem;
    }
    .message-sender {
      font-weight: 500;
      margin-right: 0.25rem;
    }
    .chat-input {
      display: flex;
      border-top: 1px solid #eee;
      padding: 0.75rem;
    }
    .chat-input input {
      flex-grow: 1;
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-right: none;
      border-radius: 0.25rem 0 0 0.25rem;
      font-family: inherit;
      font-size: 1rem;
    }
    .chat-input button {
      background-color: #4f46e5;
      color: white;
      border: none;
      border-radius: 0 0.25rem 0.25rem 0;
      padding: 0.5rem 1rem;
      cursor: pointer;
    }
    .home-link {
      display: inline-block;
      margin-bottom: 1rem;
      color: #4f46e5;
      text-decoration: none;
    }
    .home-link:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>Sankalpa</h1>
    </div>
  </header>
  
  <main>
    <div class="container">
      <a href="/" class="home-link">‚Üê Back to Home</a>
      <h1>Agent Chain Composer</h1>
      
      <div class="flex">
        <div class="card" style="flex: 1;">
          <div class="action-bar">
            <button id="addNodeBtn" class="button button-blue">+ Add Agent Node</button>
            <button id="saveChainBtn" class="button button-green">üíæ Save Chain</button>
            <button id="runChainBtn" class="button button-purple">‚ñ∂Ô∏è Run Chain</button>
            <button id="toggleChatBtn" class="button button-gray">Show Chat</button>
          </div>
          
          <div id="canvas" class="canvas">
            <div class="node" style="top: 50px; left: 50px;" draggable="true" data-id="1">
              Planner Agent
            </div>
          </div>
          
          <div id="outputContainer" style="display: none;">
            <h3>Output:</h3>
            <div class="output-container">
              <pre id="outputText"></pre>
            </div>
          </div>
        </div>
        
        <div id="chatPanel" class="card" style="width: 300px; display: none;">
          <div class="chat-container">
            <div class="chat-header">
              Collaboration Chat
            </div>
            
            <div id="chatMessages" class="chat-messages">
              <div class="message">
                <span class="message-sender">System:</span>
                <span>Welcome to Sankalpa Collaboration Chat</span>
              </div>
            </div>
            
            <form id="chatForm" class="chat-input">
              <input type="text" id="messageInput" placeholder="Type a message..." required>
              <button type="submit">Send</button>
            </form>
          </div>
        </div>
      </div>
    </div>
  </main>
  
  <footer>
    <div class="container">
      <p>Sankalpa - AI-Powered Development Automation Platform</p>
    </div>
  </footer>
  
  <script>
    // API configuration
    const config = {
        apiUrl: "http://localhost:8000", // Update this to match your API server
        endpoints: {
            listAgents: "/api/agents/enhanced",
            executeAgent: "/api/agents/execute"
        }
    };
    
    // Node management
    let nodes = [
      { id: '1', label: 'Planner Agent', position: { x: 50, y: 50 }, agentId: 'planner' }
    ];
    
    // Load available agents
    async function loadAvailableAgents() {
        try {
            const response = await fetch(`${config.apiUrl}${config.endpoints.listAgents}`);
            if (!response.ok) {
                throw new Error(`Failed to load agents: ${response.status}`);
            }
            
            const agents = await response.json();
            console.log('Available agents:', agents);
            return agents;
        } catch (error) {
            console.error('Error loading agents:', error);
            return [];
        }
    }
    
    // Load agents when page loads
    let availableAgents = [];
    loadAvailableAgents().then(agents => {
        availableAgents = agents;
    });
    
    document.getElementById('addNodeBtn').addEventListener('click', async function() {
      // If we don't have agents yet, try loading them
      if (availableAgents.length === 0) {
          try {
              availableAgents = await loadAvailableAgents();
          } catch (error) {
              console.error('Could not load agents:', error);
          }
      }
      
      // Select a random agent if available
      let agentLabel = `Agent ${nodes.length + 1}`;
      let agentId = `agent_${nodes.length + 1}`;
      
      if (availableAgents.length > 0) {
          const randomAgent = availableAgents[Math.floor(Math.random() * availableAgents.length)];
          agentLabel = randomAgent.name;
          agentId = randomAgent.id;
      }
      
      const id = (nodes.length + 1).toString();
      const newNode = {
        id,
        label: agentLabel,
        agentId: agentId,
        position: {
          x: 50 + Math.random() * 150,
          y: 50 + Math.random() * 150
        }
      };
      
      nodes.push(newNode);
      renderNodes();
    });
    
    function renderNodes() {
      const canvas = document.getElementById('canvas');
      
      // Clear existing nodes
      const existingNodes = canvas.querySelectorAll('.node');
      existingNodes.forEach(node => {
        if (node.getAttribute('data-id') !== '1') {
          node.remove();
        }
      });
      
      // Add nodes
      nodes.forEach(node => {
        if (node.id === '1') return; // Skip first node which is already in the DOM
        
        const nodeElement = document.createElement('div');
        nodeElement.className = 'node';
        nodeElement.setAttribute('draggable', 'true');
        nodeElement.setAttribute('data-id', node.id);
        nodeElement.setAttribute('data-agent-id', node.agentId || '');
        nodeElement.textContent = node.label;
        nodeElement.style.top = `${node.position.y}px`;
        nodeElement.style.left = `${node.position.x}px`;
        
        canvas.appendChild(nodeElement);
      });
      
      // Add drag events to nodes
      setupDragEvents();
    }
    
    function setupDragEvents() {
      const nodeElements = document.querySelectorAll('.node');
      
      nodeElements.forEach(nodeElement => {
        nodeElement.addEventListener('dragstart', function(e) {
          const nodeId = this.getAttribute('data-id');
          e.dataTransfer.setData('text/plain', nodeId);
          
          // Calculate the offset
          const rect = this.getBoundingClientRect();
          const offsetX = e.clientX - rect.left;
          const offsetY = e.clientY - rect.top;
          
          // Store the offset
          this.setAttribute('data-offset-x', offsetX);
          this.setAttribute('data-offset-y', offsetY);
        });
      });
      
      const canvas = document.getElementById('canvas');
      
      canvas.addEventListener('dragover', function(e) {
        e.preventDefault();
      });
      
      canvas.addEventListener('drop', function(e) {
        e.preventDefault();
        
        const nodeId = e.dataTransfer.getData('text/plain');
        const nodeElement = document.querySelector(`.node[data-id="${nodeId}"]`);
        
        if (nodeElement) {
          // Get the offset
          const offsetX = parseInt(nodeElement.getAttribute('data-offset-x')) || 0;
          const offsetY = parseInt(nodeElement.getAttribute('data-offset-y')) || 0;
          
          // Calculate new position
          const canvasRect = canvas.getBoundingClientRect();
          const x = e.clientX - canvasRect.left - offsetX;
          const y = e.clientY - canvasRect.top - offsetY;
          
          // Update position
          nodeElement.style.left = `${x}px`;
          nodeElement.style.top = `${y}px`;
          
          // Update nodes array
          const node = nodes.find(n => n.id === nodeId);
          if (node) {
            node.position = { x, y };
          }
        }
      });
    }
    
    // Chain operations
    document.getElementById('runChainBtn').addEventListener('click', async function() {
      const outputContainer = document.getElementById('outputContainer');
      const outputText = document.getElementById('outputText');
      
      outputContainer.style.display = 'block';
      outputText.textContent = 'Executing chain...';
      
      try {
        // Get agent names for display
        const agentNames = nodes.map(node => node.label);
        addMessage('System', `Executing chain with agents: ${agentNames.join(' ‚Üí ')}`);
        
        // Take the first node's agent ID for the actual execution
        // In a real implementation, we would execute each agent in the chain
        const firstNode = nodes[0];
        const agentId = firstNode.agentId || 'planner';
        
        // Get input data (could be from a form in a real implementation)
        const inputData = {
          input: "Generate a project plan for a web application"
        };
        
        // Call the API to execute the agent
        const response = await fetch(`${config.apiUrl}${config.endpoints.executeAgent}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            agent_name: agentId,
            input_data: inputData
          })
        });
        
        if (!response.ok) {
          throw new Error(`API request failed: ${response.status}`);
        }
        
        const result = await response.json();
        
        // Display the result
        outputText.textContent = JSON.stringify(result, null, 2);
        
        // Also add as message
        addMessage('System', 'Chain execution completed successfully');
      } catch (error) {
        console.error('Error executing chain:', error);
        outputText.textContent = `Error: ${error.message}`;
        addMessage('System', `Error executing chain: ${error.message}`);
      }
    });
    
    document.getElementById('saveChainBtn').addEventListener('click', function() {
      try {
        const chain = {
          name: "Sample Chain",
          description: "A chain created in the composer",
          nodes: nodes,
          created_at: new Date().toISOString()
        };
        
        // Save to local storage
        localStorage.setItem('savedChain', JSON.stringify(chain));
        
        // Create download file
        const dataStr = JSON.stringify(chain, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        
        const exportName = 'sankalpa_chain_' + new Date().getTime() + '.json';
        
        // Create download link
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportName);
        linkElement.click();
        
        alert('Chain saved successfully!');
      } catch (error) {
        console.error('Error saving chain:', error);
        alert(`Error saving chain: ${error.message}`);
      }
    });
    
    // Chat functionality
    const chatPanel = document.getElementById('chatPanel');
    const toggleChatBtn = document.getElementById('toggleChatBtn');
    
    toggleChatBtn.addEventListener('click', function() {
      const isVisible = chatPanel.style.display !== 'none';
      chatPanel.style.display = isVisible ? 'none' : 'block';
      toggleChatBtn.textContent = isVisible ? 'Show Chat' : 'Hide Chat';
    });
    
    document.getElementById('chatForm').addEventListener('submit', function(e) {
      e.preventDefault();
      
      const messageInput = document.getElementById('messageInput');
      const message = messageInput.value.trim();
      
      if (message) {
        addMessage('You', message);
        messageInput.value = '';
        
        // In a real implementation, we would send the message to an API
        // For now, just send a simulated response
        setTimeout(() => {
          addMessage('Assistant', `I'll help you with your chain: "${message}"`);
        }, 1000);
      }
    });
    
    function addMessage(sender, text) {
      const chatMessages = document.getElementById('chatMessages');
      
      const messageElement = document.createElement('div');
      messageElement.className = 'message';
      
      const senderElement = document.createElement('span');
      senderElement.className = 'message-sender';
      senderElement.textContent = `${sender}:`;
      
      const textElement = document.createElement('span');
      textElement.textContent = ` ${text}`;
      
      messageElement.appendChild(senderElement);
      messageElement.appendChild(textElement);
      
      chatMessages.appendChild(messageElement);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    // Initialize
    setupDragEvents();
  </script>
</body>
</html>